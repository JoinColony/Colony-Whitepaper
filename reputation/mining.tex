\newcommand{\rc}{root colony\ }
\newcommand{\rct}{root colony token\ }
\newcommand{\rcts}{root colony tokens\ }
\newcommand{\rcth}{root colony token holder\ }
\newcommand{\rcths}{root colony token holders\ }

\section{Calculating Reputation: Miners \& Merkle Proofs}\label{sec:reputationmining}
We see that the reputation system is a core component of the decentralised colony network. By carefully balancing the rewards and penalties we aim to keep every users' incentives aligend with the colony and the colony network. Since reputation can only be \emph{earned} and not bought, the system fosters a more meritocratic from of decision making than pure token-weighted voting can hope to achieve. The continuous decay of reputation ensures that the influece conveyed by reputation is recent and up-to-date; it prevents a reputation aristocracy and allows for a fluid passing of control from one set of contributors to another over time.\\
How well the parameters of the reputation system balance out competing interests will have to be subject to empirical review when the colony network begins live operation and any parameters proposed in this document should be seen as suggestions, not prescriptions for the final network.\\
Due to the combined complexity of reputation scores across multiple colonies, domains, skills; growing due to tasks completed and disputes won; shrinking due to decay and poor performance; \textbf{reputation scores cannot be stored and calculated on-chain}. Instead, the calculations will all take place off-chain, the results of which will be reported to the blockchain by participating \rcths -- in a process resembling a proof-of-stake blockchain consensus protocol. We call this procedure \textbf{``Reputation Mining''}.\\
The calculation whose result the miners are submitting, is determined by the activites that have taken place in the colonies and can be fully deterministically derived from the ethereum blockchain. Game-theoretically the system is protected similary to the off-chain calculations of truebit and golem??? (REFREFREFERENCE) in the \emph{while the calculation cannot be done on-chain, an incorrect calculation can always be proved to be wrong.}


\subsection{The Reputation Tree and the ReputationRootHash}\label{sec:reptree}
A reputation consists of the following data:
$$
R = 
\begin{cases}
 rep_id & \textnormal{the id of a skill or domain identifying the type of reputation},\\
 colony\_id & \textnormal{the colony the reputation is held in},\\
 user & \textnormal{the address holding the skill},\\
 amount & \textnormal{the numerical value of the reputation}.
\end{cases}
$$
All individual reputations are assembled into the \textbf{``Reputation Tree''} which is a merkle tree of all individual reputations in a colony and the cumulative totals. (Note: with the \ascode{user} is set to zero, the corresponding amount is taken to represent the total of all such reputation held by users in this colony.)\\
All reputations held by all users in all colonies are ordered in a list. The elements of this list are hashes pairwise, to end up with a shorter list of hashes. This process is repeated until only one hash remains: the \ascode{ReputationRootHash}, $\mathcal{RH}$.
\begin{center}
\begin{tikzpicture}
 \node at (0,-5) (r1) {$R_1$};
 \node at (1.5,-5) (r2) {$R_2$};
 \node at (3,-5) (r3) {$R_3$};
 \node at (4.5,-5) (r4) {$R_4$};
 \node at (6,-5) (rdots) {$\cdots$};
 \node at (8,-5) (rn) {$R_N$};
 %
 \node at (0,-4) (r1hash) {$\mathcal{H}(R_1)$}
  edge[-] (r1);
 \node at (1.5,-4) (r2hash) {$\mathcal{H}(R_2)$}
  edge[-] (r2);
 \node at (3,-4) (r3hash) {$\mathcal{H}(R_3)$}
  edge[-] (r3);
 \node at (4.5,-4) (r4hash) {$\mathcal{H}(R_4)$}
  edge[-] (r4);
 \node at (8,-4) (rnhash) {$\mathcal{H}(R_N)$}
  edge[-] (rn);
 %
 \node at (1,-2.5) (r12) {$\mathcal{H}_{1,2}$}
  edge[-] (r1hash)
  edge[-] (r2hash);
 \node at (3.75,-2.5) (r34) {$\mathcal{H}_{3,4}$}
  edge[-] (r3hash)
  edge[-] (r4hash);  
 \node at (7,-2.5) (rnn) {$\mathcal{H}_{N,N-1}$}
  edge[-] (rnhash)
  edge[dashed] (6.5,-4);
 %
 \node at (2.5,-1) (r14) {$\mathcal{H}_{12,34}$}
  edge[-] (r12)
  edge[-] (r34);
 %
 \node[draw, fill=gray!5] at (4,0) (root) {\texttt{ReputationRootHash}};
 \node[right = 2mm of root] (rh) {$\mathcal{RH}$} 
   edge[-] (root);
 \node[below = 1mm of root] (dummy) {\phantom{a}}
  (dummy.north west) edge[dashed] (r14)
  (dummy.north east) edge[dashed] (rnn);
 %
 %
 \node at (4,-6) (label) {\textnormal{The Reputation Tree}};
\end{tikzpicture}
\end{center}

In the event of a starting or an intermediate array being an odd number (which will always happen for a starting array that is not a power of two), the hash contained in the last element is hashed with itself.

The \ascode{ReputationRootHash} is the data we record on the blockchain. It represents an integrity check for the entire reputation system and whenever a user wishes to make use of their reputation, the can submit a merkle proof starting at the reputation $\mathcal{R}_i$ they wish to make use of and ending at $\mathcal{RH}$.

\subsection{Calculating the new root hash}
The \rcth takes the last reputation state, and decays all reputation held by all users in all colonies, in the order of the leaves in the tree. They then take the set of reputation gains or losses due to good or bad behaviour that were not in the last state submitted, and are to be included in the next state. They apply the reputation updates to each user, in each colony, as is appropriate, to end up with a new list of reputations for all users and colonies. These new reputations are then hashed and assembled into a new merkle tree yielding an updated \ascode{ReputationRootHash}.

While the calculation is too large to be done on-chain due to technical (gas limit) and economic (gas cost) limitations, it is expected that this calculation can easily be performaed by any consumer grade laptop computer.

\subsection{Submission of a new root hash}
%
\subsubsection*{What is submitted?}
The final \ascode{ReputationRootHash} is submitted to the contract by the miner along with the number of leaves in the tree. Further, the miner also submits the IPFS/Swarm hash of a document containing the entire state tree (though this is only for convenience; any user can construct this locally based on the blockchain history).
%
\subsubsection*{Who can submit a new root hash?}
Since any user can calculate the correct root hash locally, it would be possible for \emph{any} \rcth to submit the hash to the contract.
It is however undesirable to have too many submissions for every update. We propose a mechanism that only allows some \rcths to submit results to begin with. To participate in the mining process, \rcths must stake some of their tokens to become `reputation miners'. A submission will only be accepted from a miner if \ascode{SHA3(address, N, hash, ... )} is sufficiently small.  At the beginning of the submission window, the target is set to 0 and slowly increases such that after 150 blocks all submissions are accepted\footnote{Some minimal \rct holding requirements may apply to ward off a denial of service attack with thousands of false submissions.}. Here N is some number greater than 0 and less than the number of tokens the \rcth address has staked, meaning that users with a large stake have a higher chance of qualifying to submit a hash than smaller stake holders.
%
\subsubsection*{Verifying a submission}
If only one state is submitted by the end of the submission period, then the new state is accepted, and proposals of the next state can begin to be made. This is expected to be the most common occurance.\\
If more than one state has been submitted, then either someone has made a mistake, or there is a malicious entity trying to introduce a fraudulent reputation change. In this event, the a challenge-response protocol can establish which state is incorrect (see Section \ref{sec:challengeresponse})

\subsubsection*{Mining Rewards}

When a state is accepted, a small number of (newly generated) \rcts are made available for the user who first submitted the correct state to claim as a reward. When the user claims this payout, they receive a corresponding amount of reputation in the \rc (a special mining skill, which only users in the root colony can earn by performing this task). This reputation update is no different from any other, aside from the limitations of who is able to earn it, and will be included in a subsequent reputation update cycle.

\subsection{Dealing with false submissions}\label{sec:challengeresponse}
The challenge-response mechanism detailed below relies heavily on merkle proofs, so it will be useful to establish some notation.

\subsubsection{Merkle Proofs}
Consider the merkle tree shown in figure below. In order to prove that the element \ascode{A} is in the tree with root \ascode{G}, one submits a merkle proof containing the following information: \ascode{A, [B,F], [l,l]}. The first argument is the element whose existence is to be proved. The second argument is the list of hashes that \ascode{A} should be hashed pairwise with. The last argument is an array of \ascode{l}'s and \ascode{r}'s that indicates whether the next element in question should be hashed on the left or the right of the hash calculated so far. So to show that \ascode{C} was in the tree with root \ascode{G}, the proof would be of the form \ascode{C, [D,E], [l,r]}.
\begin{center}
 \begin{tikzpicture}
  \node[shape=circle, draw] at (0,-4) (a) {\texttt{A}};
  \node[shape=circle, draw] at (1.5,-4) (b) {\texttt{B}};
  \node[shape=circle, draw] at (3,-4) (c) {\texttt{C}};
  \node[shape=circle, draw] at (4.5,-4) (d) {\texttt{D}};
  %
  \node[shape=circle, draw] at (1,-2) (e) {\texttt{E}}
   edge[-] (a)
   edge[-] (b);
  \node[shape=circle, draw] at (3.5,-2) (f) {\texttt{F}}
   edge[-] (c)
   edge[-] (d);
  %
  \node[shape=circle, draw] at (2.25,0) (g) {\texttt{G}}
   edge[-] (e)
   edge[-] (f);
 \end{tikzpicture}
\end{center}
Note also that the array of \ascode{l}'s and \ascode{r}'s nothing more than a binary representation of the leaf node's index in the tree. When expressed in this way, we refer to the index as the `path' in the merkle proof. We refer to the objects that get hashed along the way (eg \ascode{[D,E]}) as the `siblings'.
%
\subsubsection{The Challenge-Response Protocol}
We assume that the correct hash is one of the  submitted hashes. This is a reasonable assumption, as only one \rcth out of all miners is required to make a submission, and there is an incentive for them to do so (\rc reputation). Thus our task is not to validate the correct hash but to invalidate the false ones.

We must prove all but one submission incorrect by having each submission navigate a series of challenges. These \emph{challenges} refer to events that happened in the colony network within the last update cycle that have a reputation effect while the \emph{responses} to the challenges are merkle proofs that the corersponding reputation update was properly handled.

\subsubsection*{1. The Justification Tree}
 The first step is for both parties to upload a second merkle root. This is the root of a tree where each leaf represents a complete reputation state i.e. each leaf is a \ascode{ReputationRootHash}. The right-most leaf ($\mathcal{RH}_n$) is the hash they originally submitted, the left-most leaf ($\mathcal{RH}_0$) is the final accepted reputation state from the last update, and the intermediate leaves ($\mathcal{RH}_i$) represent the evolution of the reputation state after the reputation updates are applied one-at-a-time. 
 %
 \newcommand{\jrh}{\ensuremath{\mathbb{JRH}}}
 %
\begin{center}
\begin{tikzpicture}
 \node at (0,-4) (rh0) {$\mathcal{RH}_0$};
 \node at (1.5,-4) (rh1) {$\mathcal{RH}_1$};
 \node at (3,-4) (rh2) {$\mathcal{RH}_2$};
 \node at (4.5,-4) (rh3) {$\mathcal{RH}_3$};
 \node at (6,-4) (rh4) {$\mathcal{RH}_4$};
 \node at (7.5,-4) (rdots) {$\cdots$};
 \node at (9.5,-4) (rhn) {$\mathcal{RH}_n$};
 %
 \node at (0.75,-2.5) (rh01) {$j_{01}$}
  edge[-] (rh0)
  edge[-] (rh1);
 %
 \node at (2.25,-2.5) (rh12) {$j_{12}$}
  edge[-] (rh1)
  edge[-] (rh2);
 %
 \node at (3.75,-2.5) (rh23) {$j_{23}$}
  edge[-] (rh2)
  edge[-] (rh3);  
 %
 \node at (5.25,-2.5) (rh34) {$j_{34}$}
  edge[-] (rh3)
  edge[-] (rh4);  
 %
 \node at (8.5,-2.5) (rhnn) {$j_{n,n-1}$}
  edge[-] (rhn)
  edge[dashed] (8,-4);
 %
 \node at (1.75,-1) (rh02) {$j_{02}$}
  edge[-] (rh01)
  edge[-] (rh12);
 %
 \node at (4.5,-1) (rh24) {$j_{24}$}
  edge[-] (rh23)
  edge[-] (rh34);
 %
 \node at (3.7,0) (dummy14) {$j_{04}$}
  edge[dashed] (rh02)
  edge[dashed] (rh24);
 %
 \node[draw, fill=gray!5] at (5,1) (root) {\texttt{JustificationRootHash}};
 \node[right = 2mm of root] (jrh) {$\jrh$} 
   edge[-] (root);
 \node[below = 1mm of root] (dummy) {\phantom{a}}
  (dummy.north west) edge[dashed] (dummy14)
  (dummy.north east) edge[dashed] (rhnn);
 %
 %
 \node at (4,-5) (label) {\textnormal{The Justification Tree}};
\end{tikzpicture}
\end{center}
Note that in the first stage of the tree, every pair of leaves is hashed, and so any pair has a shared merkle proof to the root.\\
Any two differing submitted states agree on the first leaf $\mathcal{RH}_0$ (the \ascode{ReputationRootHash} accepted at the end of the previous iteration of the mining process), and disagree on the last leaf $\mathcal{RH}_n$. Somewhere there is a transition  ($\mathcal{RH}_i$ to $\mathcal{RH}_{i+1}$) where they agree on the starting state but disagree on the result. This transition is meant to be the effect of a single reputation update, the calculation of which is able to be done on-chain. \\
First, however, we must establish where the two overall calculations submitted differ.

\subsubsection*{2. Searching for the discrepancy}
The contract requires both parties to submit merkle proofs that specific reputation updates were handled correctly. It begins by pseudorandomly picking a reputation updating transaction from the first half of the log (REFREFERENCE) (say the $i^{th}$ update for some $i<\frac{n}{2}$) and requires both parties to provide:\\
\begin{itemize}
 \item[(i)] The root hash before the update was applied ($\mathcal{RH}_{i-1}$)
 \item[(ii)] The root hash after the update was applied ($\mathcal{RH}_i$)
 \item[(iii)] A merkle proof showing that the pair ($\mathcal{RH}_{i-1}, \mathcal{RH}_i$) is correctly included in the justification tree
\end{itemize}

The contract then repeats this process using a binary search algorithm. If the merkle proof (iii) for both submissions had the same sibling values almost all the way up, but differing only in the the final sibling, then the discrepancy must occur later (i.e. the two sumbissions differ at some $i^\prime > \frac{n}{2}$) whereas if the merkle proofs already differ at an earlier sibling, then the submissions must also differ in an update before $\frac{n}{2}$.

The contract pseudorandomly selects a reputation update from within the subtree in which the first discrepancy is known to lie. Each newly submitted proof further reduces the size of the subtree by a factor of two\footnote{ By examing precisely at which sibling the first discrepancy occurs, some stages of the binary search could be skipped. However, in order to accomplish this all the siblings of the proof that first completed the challenge would need to be stored on the blockchain, so it’s likely it’s more gas efficient to just do the ‘naive’ binary search.}.

If at any point in the process, a submission does not respond to the challenge requested, in a timely fashion they forfeit, and are assumed to be incorrect. If all submissions continue to be defendes successfully, ultimately, the location of the first discrepancy in the series of state transitions is found: the submissions aggree on (i) but not (ii). The contract then requires
\begin{itemize}
 \item[(iv)] A merkle proof for the reputation ($R_j$) affected by the $i^{th}$ update trasaction.
\end{itemize}
Note: in point (iv), the \emph{exact same} merkle proof that proves the inclusion of $R_j$ (before the reputation update) in the root $\mathcal{RH}_{i-1}$ must also prove the inclusion of $R_j$ (after the reputation update) in the root $\mathcal{RH}_i$. This is because the trees $\mathcal{RH}_{i-1}$ and $\mathcal{RH}_i$ differ in only a single leaf.\\

Finally, this transition is then calculated on-chain to determine which is the correct answer. The submission that has been proved to be incorrect is rejected.

In the event of more than two submissions, this process is conducted in parallel between multiple pairs of submitted hashes, and then repeated, until only one submission remains.




\subsection{Implementation Details}
%
\subsubsection{Keeping track of reputation changes}
%
There are two types of reputation update that occur:
\begin{itemize}
 \item Decay of existing reputation
 \item Addition or removal of reputation as a reward or punishment.
\end{itemize}
All reputation decays, and so it is only the latter that is explicitly recorded on the blockchain when an event occurs. Specifically, when a reputation affecting event occurs, an entry is added to the `reputation update log' in the \rc. Such an entry consists of
\begin{itemize}
 \item[$R$] The reputation to be updated 
 \item[$\Delta_R$] The reputation change
 \item[source] An address if the reputation is coming from someone, zero otherwise
 \item[$n\_updates$] The cumulative number of all reputation changes that will have been made when this log entry is correctly processed.
\end{itemize}
Recall also from section \ref{sec:reptree} that a reputation consists of
\[
R = 
\begin{cases}
 rep\_id & \textnormal{the id of a skill or domain identifying the type of reputation},\\
 colony\_id & \textnormal{the colony the reputation is held in},\\
 user & \textnormal{the address holding the skill},\\
 amount & \textnormal{the numerical value of the reputation}.
\end{cases}
\]
Furthermore for each $rep\_id$, the following data is also known
\[
  rep\_id \rightarrow 
  \begin{cases}
    parent\_id &	\textnormal{the rep\_id of the parent domain/skill}\\
    parent\_n\_id &	\textnormal{the rep\_id of the $n^{th}$ parent}\\
    generation &	\textnormal{total number of parents}\\
    children\left[\right] &	\textnormal{array of children}\\
    n\_children &	\textnormal{total number of children}
  \end{cases}
\]
When a user earns reputation in a skill or domain, s/he also earns reputation in all parents and thus corresponds to \ascode{generation} number of reputation updates. Alternately, when a user loses reputation, they also lose reputation in all parents and all children representing a total number of updates of \ascode{generation + n\_children}. (Note: parent\_id and parent\_n\_id are not used here; they are used during dispute escalation - see Section REFREFREF).

It is only by recording the number of parent reputations (\ascode{generation}) and how many reputations have been updated already in this update cycle (via \ascode{n\_updates}) that the resolution protocol is able to perform the binary search of the justification state trees submitted by the disagreeing users. At the start of the challenge protocol, the contract can look up the last entry in the update table for the cycle under consideration, and work out how many updates have occurred this cycle based on the number of updates prior and the number of parent reputations. It can then conduct the binary search.

When the discrepant state transition is found, the users supply the index of the update on-chain that corresponds to that reputation update. This means that the contract does not have to iterate over the whole list expensively, but the contract can easily check the correct reputation update is being considered, and then confirm that the calculation made corresponds to the correct reputation update. In the event that the discrepant transaction is a decay transaction, which is easily determined by the merkle path corresponding to an index smaller than the number of leaves in the tree at the end of the last successful update, they must also supply a merkle proof that the starting value assumed for the user corresponds to the value that user had at the end of the last update cycle.

Recording the number of leaves in the tree is required to allow the binary search to occur and accommodate the decay calculations that must be done at the start of each update. Before any new reputation is earned or lost in an update cycle, all existing reputations owned by users decays (see next section REFREFREF). There is a decay calculation for every leaf in the previously accepted tree. We do the decay calculations first to give users the benefit of the doubt during reputation updates so they do not lose reputation they have only just earned to premature decay.

When a user earns reputation in a new skill, at least one new leaf is added to the tree - if they have not earned reputation before in some of the parents, then they will also cause further new leaves to be added. New leaves will also be added if they are the first user in a colony to earn those particular skills, making the total reputation for that skill in the colony non-zero. During a dispute, when the user proves that they have included the update in the tree, it is not possible to check (efficiently) on-chain that they should not have added it to an existing leaf instead. However, because during a dispute we are always playing two submissions off against the other, one of two things will be true:

Both submissions add a new leaf to the tree. If there was a discrepancy, then it is in the maths conducted on this leaf, not the addition of the leaf itself. The maths can be checked on-chain to establish which result is correct.
The other submission adds the new reputation to an existing leaf (the correctness of which can be checked on-chain easily). In this case, the user who added the leaf incorrectly is wrong.



\subsubsection{Transfers of reputation between accounts}\label{sec:reptransfer}

blabla reputation cannot be transferred blabla.... but we have a mechanism where A loses and B gains... this has to be modelled as a transfer because....

If the entry in the reputation update log indicates that the reputation has come from another user, then this entry represents updates of all the parents of the reputation being gained by one user, and updates of all the parents and children of the reputation being lost by the other. However, we have to ensure that the user who is losing reputation still has the reputation to lose if another user is gaining it.

To achieve this, all the transactions that correspond to updating the reputations of the user gaining the reputation are done first. In the event such a transaction must be proved to be correct in the resolution protocol, the users can provide a proof of the losing user’s reputation, prior to them losing it in this update, and this can be compared to the amount of reputation intended to be gained. Whichever is smaller is used as the amount of reputation the user is gaining during the calculations.

Then, when calculating the reputation deduction to be applied to the losing user, the reputation that defined the context should be done last i.e. all the children (and parents) should be considered first, as it is the amount of the reputation that defined the context that will determine the fraction lost of each of the children reputation. If any of these calculation need to be proved correct during the resolution protocol, 


\subsubsection{The Reputation Decay Process}\label{sec:repdecay}
...
