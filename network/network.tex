\section{The Colony Network on Ethereum}\label{sec:colonynetwork}

The Colony Network consists of a collection of contracts on the Ethereum blockchain. The contracts that must be deployed to instantiate the Colony Network are:

\begin{itemize}
\item The \code{ColonyNetworkResolver}
\item The \code{ColonyFactory}
\item The \code{ColonyNetwork} contract (and associated \code{EternalStorage} contract, described later)
\end{itemize}

The \code{ColonyFactory} contract deploys instances of the \code{Colony} contract, alongside associated \code{EternalStorage} and \code{EternalWallet} contracts.

We want to ensure the future upgradability of the deployed system as we foresee the Colony Network being continuously developed. Providing an upgrade path is important to allow people to use Colony without preventing themselves using new features as they are added to the Network. This motivates the existence of the \code{Eternal} contracts, which can be passed from old to new instances of their associated contracts with no loss of data.

\subsection{Contract overviews}

\subsubsection{ColonyNetworkResolver contract}
A very simple, static contract that acts only as a pointer to the location of the ColonyNetwork Contract. The address of the \code{ColonyNetworkResolver} contract will never change, nor will we want it to. The address to which it points can be changed, initially by the Colony team, but ultimately only under the direction of the \code{ColonyNetwork} contract itself.

\subsubsection {ColonyNetwork contract}

The Colony Network hinges on the Colony Network Contract, which acts as the hub of the network. This contract is primarily responsible for managing the reputation mining process (described in section \ref{sec:reputationmining}), but also for general control of the network --- for example, setting the fees associated with using the network, or deploying a new version of the \code{ColonyFactory}.

\subsubsection {ColonyFactory contract}
This contract is used to deploy new instances of the \code{Colony} contract. These can either be new colonies, or part of the process of upgrading a colony.

We stress that in the case of a colony, the choice of upgrading the underlying \code{Colony} contract will never lie with the Colony Network. While the network is in control of what upgrades are available, they are not able to force an update upon a colony.


\subsection{Contract security}\label{sec:escape-hatches}
While we aspire to bug free contracts, the adoption of a `defensive programming' mentality endeavours to limit the impact of any issues that manifest in the deployed contracts.

At launch, colonies will be able to be put into a `recovery mode'. In this state, whitelisted addresses are able to access functions that allow the state of the contract to be directly edited --- in practise, this will correspond to access to the functions in the \ascode{StorageContract} to allow setting of variables, as well as the upgrade function. With the agreement of multiple whitelisted addresses, the contract will then be able to be taken out of recovery mode once the contract has been returned to a rational state. Removal from recovery mode requires the approval of multiple whitelisted addresses. This ensures that a single whitelisted address cannot, in a single transaction, enter recovery mode, make a malicious edit, and then exit recovery mode before the other parties on the whitelist have had a chance to react.

In general, the contract may enter `recovery mode' due to:
\begin{itemize}
 \item A transaction from a whitelisted address signalling that the contract should enter recovery mode.
 \item Something that should always be true of the colony not being true --- for example, after a task payout checking that the amount of funds promised to tasks and not yet paid out is still less than the balance of the colony. If not, then abort the transaction and put the contract into recovery mode.
 \item A qualitative trigger suggesting something amiss --- perhaps too many tokens have been paid out in a short amount of time.
\end{itemize}

Any approvals from whitelisted addresses to leave recovery mode must be reset whenever a variable is edited. A whitelisted address agreeing to leave recovery mode records the timestamp at which the agreement occurred, and any change of variables also update a timestamp indicating the last edit. When attempting to leave recovery mode, only agreements made after the last edit are counted towards meeting the threshold.\footnote{We note that this is a loop only limited by the number of whitelisted addresses. An alternative implementation or a hard cap on the number of whitelisted addresses in each colony will therefore be required to ensure recovery mode can always be left.}

The first whitelisted address is added at colony creation and is the creator of the colony. Whitelisted addresses can be added or removed by a simple majority vote of existing whitelisted addresses. We recommend that the Colony Foundation be added as one of these whitelisted addresses as a `trusted party'.