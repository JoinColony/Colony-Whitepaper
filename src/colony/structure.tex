\section{Structure of a Colony}\label{sec:colony-structure}
Colonies exist to enable collaboration between their members, and direct collective efforts towards common goals. Facilitating effective division of labour, management of incentives, and allocation of resources are therefore some of the most important functions of the Colony protocol.

\subsection{Domains and roles}\label{sec:domains}\label{sec:roles}

The essential structure of the colony revolves around domains and the roles that addresses may hold in them. These two concepts jointly define the structure and security of a colony and provide a flexible framework for creating colonies of many kinds.

\subsubsection{Domains}

Without structure, a large colony could quickly become difficult to navigate due to the sheer number of participants and interactions taking place --- domains solve this problem. A domain is like a folder in a shared filesystem, except instead of containing files and folders, it can contain subdomains, funding, and expenditures. This simple modularity enables great flexibility as to how an organisation may be structured. A toy example is shown in in Figure \ref{fig:domainhierarchysample}.

\begin{figure}[h]
    \centering
 \begin{tikzpicture}
   \node[ellipse,draw, dashed] at (0,0) (tld) {Root Domain};
   \node[ellipse,draw, dashed] at (-3,-2) (design) {Design};
   \node[ellipse,draw, dashed] at (0,-2) (development) {Development};
   \node[ellipse,draw, dashed] at (3,-2) (product) {Product};
   \node[ellipse,draw, dashed] at (-1.5,-4) (frontend) {Frontend};
   \node[ellipse,draw, dashed] at (1.5,-4) (backend) {Backend}
    (tld.-120) edge[->, bend left=45, in=-120] (design.north)
    (tld.-90) edge[->, out=-60, in=120] (development.north)
    (tld.-60) edge[->, bend left=45, out=-60, in=120] (product.north)
    (development.-120) edge[->, bend left=45, in=-120] (frontend.north)
    (development.-60)  edge[->, bend left=45, out=-60, in=120] (backend.north);
 \end{tikzpicture}
 \caption{Parts of a domain hierarchy for a colony developing a web service.}
 \label{fig:domainhierarchysample}

\end{figure}

Among other things, this compartmentalisation of activity provides an essential benefit to the colony as a whole by making reputation \textit{contextual}. When arbitration occurs, it occurs at a specific level in the colony's domain hierarchy. This means that people with relevant contextual knowledge can be included for their opinion, and that when arbitration occurs, the whole colony is not required to participate in the dispute.

It is ultimately up to individual colonies to decide how they wish to use domains --- some might only use them for coarse categorisations, whereas others may use them to precisely group only the most similar expenditures together, or even multiple expenditures that other colonies would consider a single expenditure. Some might use domains to represent long-lived organizational departments, while others might use them more ephemerally, to represent projects with start and end dates. We aim to provide a general framework that colonies may use however they see fit, and to be prescriptive only where necessary.

\subsubsection{Roles}

Access control in a colony is organized around the concepts of \textbf{roles} and their accompanying \textbf{permissions}. There are six different roles (roughly in order of influence): Recovery, Root, Arbitration, Architecture, Funding, and Arbitration. Each role provides a bundle of semantically-related functionality, giving role-holders \textit{permission} to call certain privileged functions.

With the exception of the Recovery and Root roles, all roles are domain-specific (much like permissions in a Unix file system are directory-specific), with the rule that roles held in a parent domain are inherited in all child domains. Put another way, holding a role in a domain gives you that role in the entire \textit{subtree} rooted in that domain. To implement this inheritance, permissioned functions require a \textit{domain proof} of the following arguments:

\begin{itemize}
\item \texttt{permissionDomainId} - The (parent) domain in which the address holds the role.
\item \texttt{childSkillIndex} - The index of \texttt{domainId} in \texttt{permissionDomainId}'s \texttt{children} array.
\item \texttt{domainId} - The (child) domain in which the action is being taken.
\end{itemize}

These arguments can be evaluated on-chain in constant time to determine whether the address is authorized to call the privileged function.

Roles are held by Ethereum addresses. This means that roles can be given to human administrators, or assigned to contracts which implement more complex behavior (such as voting mechanisms). These types of contracts are known as \textbf{extensions} and are discussed in-depth in Section \ref{sec:extensions}. The use of extensions to flexibly `plug-in' various decision-making mechanisms is a key concept in the Colony protocol.

\subsubsection*{Recovery}

The recovery role gives addresses access to the colony's emergency `recovery' functionality, which allows for arbitrary state-changes to the colony's data. Recovery mode is described in more detail in Section \ref{sec:escape-hatches}.

\subsubsection*{Root}

The root role gives addresses access to high-level administrative functions in the colony, such as setting colony-wide parameters, upgrading the colony, and minting new internal tokens. The root role also gives addresses the ability to assign roles throughout the colony (including in the root domain).

\subsubsection*{Arbitration}

The arbitration role give addresses the ability to make domain-specific state changes, meant as a means of resolving disputes. This role also gives permission to emit reputation penalties (but not reputation increases).

\subsubsection*{Architecture}

The architecture role gives addresses the ability to create new domains in a colony, as well as assign roles in those new domains. Unlike the root role, architecture role holders cannot edit roles in the domain in which they hold the role, only in subdomains.

\subsubsection*{Funding}

The funding role gives addresses the ability to move tokens between funding pots. In practice, this means that this role is responsible for allocating money amongst domains and for funding expenditures. Financial management in a colony is described in more detail in Section \ref{sec:finance}.

\subsubsection*{Administration}

The administration role gives addresses the ability to create and manage (but not fund) expenditures, the basic incentive unit in a colony, described in Section \ref{sec:expenditures}. \\

Broadly, roles are designed as a `separation of powers': different roles must work together to carry out the functioning of a colony. For example, the administration role can create an expenditure, but only the funding role can actually provide the resources, while the arbitration role resolves disputes as they arise. Complex extensions may require multiple roles in order to function properly (such as `tasks', which requires both the arbitration and administration roles.

The intention is that, since the roles represent semantic bundles of functionality, it will be possible to develop \textit{specialized} mechanisms for mediating access to the underlying functionality (i.e. specialized funding mechanisms and specialized dispute-resolution mechanisms, as opposed to a general-purpose `voting' mechanism meant to handle all possible decisions).

Colony's long-term vision is of \textit{permissionless organizations}; however, early colonies may find that a larger emphasis on human moderators to be useful. Over time, we hope that colonies will devolve more and more decision-making away from human moderators to extensions which implement permissionless functionality. We will refer to colonies which make substantial use of these extensions as \textit{permissionless colonies}.

\subsection{Funding and expenditures}\label{sec:expenditures}\label{sec:finance}

All tokens and currencies are administered by the colony contract; it is responsible for all the bookkeeping and allocations. The former are managed via funding pots, the latter via expenditures.

\subsubsection{Funding pots}

Each domain and each expenditure in a colony has an associated \emph{funding pot}. A funding pot can be thought of as a wallet specific to a particular domain or expenditure. To each funding pot, the colony contract may associate any number of Ether or ERC20-compatible tokens it holds. Depending on context, the funds in a funding pot may be referred to as the payout, bounty, budget, salary or working capital. In addition to the funding pots, there is a special \emph{rewards pot} which accumulates tokens to be distributed to members as \textit{rewards} (see Section \ref{sec:revenue}).

Only addresses holding the \textbf{funding} role may move tokens; the rule is that they may move tokens between any two pots in the subtree rooted in the domain in which they hold the role. It is the expectation that the funding role will in many cases be assigned to an \textit{extension contract} implementing a specialized decision-making mechanism, such as the \textit{funding queue} described in Section \ref{sec:funding-queues}.

\subsubsection{Expenditures}

The basic incentive unit of a colony is the `expenditure'. An expenditure represents an allocation of resources \textit{out of} a colony, and thus accepts no further subdivison or delegation. An expenditure has several properties:

\begin{itemize}
\item An \texttt{owner} (the address which created the expenditure).
\item A \texttt{status} (active, cancelled, or finalized).
\item One or more \texttt{recipient}s.
\item \texttt{payouts} for each recipient, denominated in one or more tokens.
\item Optionally, a per-recipient \texttt{skill}.
\item Optionally, a per-recipient \texttt{payoutModifier}.
\item Optionally, a per-recipient \texttt{claimDelay}.
\end{itemize}

The owner is responsible for setting the properties of the expenditure. The recipients are simply Ethereum addresses. While it is anticipated that recipients will be individuals, there is nothing to prevent these addresses being contracts under the control of multiple people.\footnote{With the protocol described in this version of the document, any reputation earned would be assigned to the contract in question and not able to be moved to the appropriate users. In these cases, it might be better to develop an extension contract which would determine the per-user allocation in advance and configure the expenditure accordingly.}

Once the expenditure is finalized, all properties become immutable (but subject to arbitration) and payouts can be claimed (and reputation earned). Prior to finalization, the owner has the ability to cancel the expenditure entirely. Any funds that have already been assigned to the expenditure via funding proposals can be reassigned to the domain that the expenditure was created in.

Defining the payouts for each recipient, of course, does not provide the funds --- this must be done through the funding mechanisms in Colony. Payouts do not have to all be in the same token, and an expenditure's payouts can be made up of an arbitrary number of tokens.

The expenditure is meant to be an abstract unit, and so contains optional attributes to support more complex behavior (see Section \ref{sec:extensions}). For instance, the \texttt{payoutModifier} and \texttt{claimDelay} can be used to implement a rating and review system, where good or bad reviews lead to an across-the-board reputation increase (or payout decrease) for a recipient, while the \texttt{claimDelay} is set to allow for any dispute processes to complete before funds can exit the colony. \\

Once the tokens have been paid out, they are under the control of the recipient --- there is no way to reclaim the funds. The funds have to cross the `Cryptographic Rubicon' somewhere in the system (by the nature of the blockchain), and it makes sense to do so here.\footnote{Currently, the only way this rule can be broken is by the Colony conspiring to abuse the `arbitrary transaction' feature described in Section \ref{sec:arbitrary-transaction}.}

\subsection{Internal tokens}\label{sec:colony-tokens}

Every colony has its own ERC20-compatible `internal token'. These are the tokens that, when earned as an expenditure payout, also generate reputation for the receiver. What these tokens represent apart from this is up to the colony to decide. For example, they may have financial value, or they may be purely symbolic; some possible scenarios are outlined in this section. In addition, colonies may `bring their own token' and designate an existing token (such as Ether or DAI) as reputation-bearing. Note that the internal token cannot be changed once a colony has been created, so \textit{choose wisely}.

In cases where a colony creates a new token, that colony is in control of the supply of the token. Specifically, \textbf{root} role holders can mint tokens at-will. In some cases, this may look like a founder managing the token supply unilaterally, while in other cases colonies may manage the minting process via an extension contract (see Section \ref{sec:colony-token-management} for an example).

\subsubsection*{Tokens as early rewards}

One of the chief benefits of a colony having its own token is that it can offer rewards for work before it has any revenue or external funding to draw on.
A new colony may offer token payouts for tasks that people may accept in the hope that the reputation earned by these token payments (and the future revenue earned by the colony) will eventually lead to financial rewards. By allowing `spending' before fund-raising, the financial burden during the start-up phase of a new colony is eased. Once a colony is profitable, payment in tokens may be the exception rather than the norm.

\subsubsection*{Tokens representing hours worked}

We could imagine a colony in which all tasks are paid in Ether, but include a number of the colony's own tokens as well, equal to the expected number of hours worked on a task. The members of the colony would be responsible for assigning `correct' token and Ether payouts to tasks. This extra responsibility would also ensure users doing the same amount of work received the same reputation gain, rather than the reputation gain being dependent on the rates they charged.

\subsubsection*{Tokens as performance-based bonuses}

Alternatively, we could imagine a colony which seeks to balance predictable compensation (i.e. salaries) with performance-based incentives. Such a colony could pay out salaries in a token such as Ether or DAI, and reserve their internal token for performance-based bonuses (i.e. for hitting quarterly OKRs). Such an approach makes reputation (and decision-making power) a function of achievement, without making members of the colony feel as though their ability to pay rent depends on their ability to hit quarterly goals.

\subsection{Revenue and rewards}\label{sec:revenue}

A colony may sell goods and services in exchange for Ether or any ERC20-compatible tokens. Whenever a colony receives such payments, we say that the colony has earned \emph{revenue}. Revenue is distinct from a colony's working capital: the latter is the sum of all tokens held by the colony in various domains (see Section \ref{sec:finance}), while the former is implicitly defined as the colony's token holdings not yet accounted for in any of the existing pots.

There is an expectation that some fraction of any Ether or other valuable tokens earned by the colony are paid out to their members. `Members', in this context, means accounts holding both tokens and reputation in the colony. Whenever a colony distributes a portion of revenue to its members, we say that the colony is paying out \emph{rewards}. It is expected that most of the revenue will \emph{not} go towards rewards, but towards replenishing the working capital.

\subsubsection{Processing revenue}

Revenue accumulates as the colony receives transfers of tokens. In order to be processed, any user can make a special \texttt{claimColonyFunds} transaction, indicating for which token they wish to process accumulated revenue.

The transaction then calculates the amount of token-denominated revenue that has accumulated since the last such transaction, and transfers some (small) percentage to the colony rewards pot. The remainder is then made available to the colony as working capital. The percentage split is configurable by the \textbf{root} role via the \texttt{setRewardInverse} function.

\subsubsection{Claiming rewards from the rewards pot}\label{sec:claimrewards}

Rewards accumulate in the rewards pot. To trigger an actual payout to users (i.e. to make rewards claimable) a \textbf{root} user makes a special \texttt{startNextRewardPayout} transaction (no more than once every \rewardclaimduration\ days), initiating a process by which all members may claim a payout based on the reward pot's holdings.

This reward payout transaction includes the specific currency that should be paid, and only one currency is handled at a time. Once the process begins, all users' tokens are locked until they claim their payout. Locking is necessary because the token balance of each account factors into the rewards formula of equation \eqref{eq:reward-claim}. Locking is done by incrementing the token's \texttt{totalLockCount}.

Our \texttt{TokenLocking} contract contains a locking mechanism ensuring that a user cannot move tokens while they have (token-weighted) votes to reveal; we use the same mechanism here to ensure that a user cannot move tokens after a payout is approved by the members of the colony but before the user has claimed their rewards. The colony has a counter for each user that is incremented whenever they claim a payout; they can also waive their claim to a payout that will increment this counter. \\

\textbf{Rewards are only available to accounts that hold both tokens and reputation}, and the amount claimable by each account depends on \emph{both} token balance and reputation (see equation \eqref{eq:reward-claim} below). Therefore we need to have a similar behaviour to `lock' the reputation of the users for the payout. When a payout is activated, the current state of the reputation tree is recorded in the payout itself. Users are paid out according to their reputation in this state, rather than the most recent state, to ensure all users get an appropriate payout and to avoid exploiting the system (which might otherwise be possible via e.g. delaying reward collection until after completing a task, increasing their reputation).

\subsubsection{The rewards formula}

The amount that each user ($u_i$) of a colony ($\mathcal{C}$) is entitled to claim ($p_i$) is a function of their colony token holdings ($t_i$) and their total reputation in the colony ($r_i$):

\begin{equation}\label{eq:reward-claim}
 p_i = \left(\frac{t_i r_i}{T \times R}\right)^{\frac{1}{2}} \qquad \textnormal{where} \quad T = \sum\limits_{u_j\in \mathcal{C}} t_j \quad\textnormal{and}\quad R = \sum\limits_{u_j\in \mathcal{C}} r_j.
\end{equation}

This is a (normalised) geometric average of the user's token holdings and reputation. We note that this is very unlikely to payout all the tokens set aside for a payout --- the only way it would do so is if everyone had the same proportion of reputation in the colony as they did proportion of tokens in the colony. However, the geometric average is the natural way to fairly capture the influence of two variables with different ranges, and ensures that large token holders must earn large amounts of reputation to get the most from the payouts. The total reputation and user reputation in the colony are all provable on-chain at claim time via a Merkle proof that the \ascode{ReputationRootHash} (Section \ref{sec:reputationmining}) contains some values claimed by the user; the user's balance of colony tokens and the total number of tokens issued is trivial to lookup.

After some sufficiently long period of time (\rewardclaimduration\ days), all unclaimed tokens can be reclaimed on behalf of the colony by a user, and the payout closed. Any users that have not claimed their payout by that point will still have their tokens locked, and they will remain locked until they issue a transaction waiving their claim to the payout (indeed, they already passively did this by not claiming it in a timely fashion). Unclaimed tokens are returned to the rewards pot and become part of the next reward cycle.

\subsection{The reputation system}\label{sec:reputation}

Reputation is a number associated with each user which attempts to represent objectively the value of that user's recent contributions to the colony. Reputation is used to weight a user's influence in decisions related to the expertise they have demonstrated, and to determine amounts owed to a colony's members when rewards are disbursed. Because reputation is awarded to users by either direct or indirect peer assessment of their actions, we argue that influence and rewards can be seen as being (roughly) distributed by merit.

Colony aims to be broadly meritocratic. Consequently, the majority of decisions in a permissionless colony are weighted by the relevant reputation. Unlike tokens, reputation cannot be transferred between addresses, as it represents an appraisal of the address's activities by their peers. Reputation must therefore be earned by direct action within the colony. Reputation that is earned will eventually be lost through inactivity, error, or malfeasance; a description of how reputation is gained and lost is given in Section \ref{sec:earning-losing-rep}.

\subsubsection{Types of reputation}

\subsubsection*{Reputation by domain}\label{sec:rep-by-domain}

The hierarchical structure of a colony was described in Section \ref{sec:domains}. Reputation is earned in this hierarchy, and a user has a reputation in all domains that exist --- even if that reputation is zero. When a user earns or loses reputation in a domain, the reputation in all parent domains changes by the same amount. In the case of a user losing reputation, they also lose reputation in all child domains, but in this case the child domains lose the same \textit{fraction} of reputation that was lost in the original domain. If a reputation update would result in a user's reputation being less than zero, their reputation is set to zero instead. \\

An example makes this clearer. Suppose a colony has a `development' domain which contains a `backend' domain and a `frontend' domain, as in Figure \ref{fig:domainhierarchysample} on page \pageref{fig:domainhierarchysample}. Any time a member of the colony earns reputation for work completed in the backend domain, it will increase their backend reputation, their development reputation and their reputation in the all-encompassing root domain of the colony. Reputation earned in the development domain will only increase the development and root domain reputation scores of the user.

Later, the user behaves badly in the `development' domain, and they lose 100 reputation out of the 2000 they have in that domain. They also lose 100 reputation in the parent domains, and 5\% $\left(\frac{100}{2000}\right)$ of their reputation in each of the child domains of the `development' domain (which in this example, includes both frontend and backend domains).

\subsubsection*{Reputation by skill}\label{sec:rep-by-skill}

We envision domains to mostly be used as an organisational hierarchy within a colony. However, this would not necessarily capture the \emph{type} of work that a user completed to earn their reputation. If the domain were a project, with tasks involving both design and development work, reputation earned by completing tasks related to these skills would not be distinguishable. To have a more granular account of the work a user completes to earn their reputation, a skill cloud is also maintained.

This global cloud of skill tags is available to all colonies, and is curated and maintained by the \rc. When a task is created, as well as being placed in a particular domain in the colony, it is also tagged with one or more skills from the skills cloud. When the worker earns reputation for successfully completing the task, they will earn reputation in all skills the task was tagged with, with the reputation divided uniformly amongst the skills. This is in addition to the reputation earned in the relevant domains. Conversely, if they are to lose reputation because their work is found inadequate, they will lose equivalent reputation in all associated skills.

Even though the skills cloud is universal, specific skills reputation is unique to each colony. Earning reputation in a skill in one colony has no effect on the user's reputation in that skill in any other colonies.

\subsubsection*{Reputation by colony}\label{sec:rep-by-colony}

A user's total reputation in a colony is their reputation in the root domain. This is the reputation they will be voting with in any decisions that require input from everyone in a permissionless colony (i.e. modifying colony-wide parameters). Reputation in a colony has no effect outside the colony. In particular, reputations held in one colony have no bearing on reputations held by the same account in another colony.

\subsubsection{Earning and losing reputation}\label{sec:earning-losing-rep}

There are three ways to earn reputation in a colony.\footnote{The \rc\ is a special case where reputation may also be earned by reputation mining (see Section \ref{sec:reputationmining}).} The first (and by far the most common) is through receiving a payout via an expenditure. The second is through the arbitration process. The third way to earn reputation is upon the creation of a colony and the associated bootstrapping process.

Reputation losses broadly occur as the result of arbitration, and extension contracts (see Section \ref{sec:extensions}) makes it possible to implement mechanisms which involve reputation penalties (such as tasks and disputes). In addition, all reputation earned by users is subject to a continual decay over time.

The rest of this section outlines each of these mechanisms, with references to the more detailed descriptions given elsewhere where appropriate.

\subsubsection*{Reputation change via expenditures}

Whenever an expenditure recipient receives a payout denominated in the colony's internal token, the recipient also receives some amount of reputation, scaled by that recipient's \texttt{payoutScalar}. A value of 1 gives reputation equivalent to the token payout, but a multiple of up to 2x is possible. The reputation is earned in the domain (and all parent domains) of the expenditure, and divided equally among any skills associated with that recipient. Note that reputation \textit{penalties} are not possible via expenditures, but rather are made via the \textbf{arbitration} role.

\subsubsection*{Reputation change as a result of arbitration}\label{sec:earning-rep-in-disputes}

Arbitration role holders have the ability to emit arbitrary reputation penalties (but not increases) in both domains and skills. While this might seem to be a significant power available to arbitration role holders, recall that this role will in many cases be assigned to extension contracts, which will mediate this ability via various mechanisms, such as a dispute process (see Section \ref{sec:objections-and-disputes}).

\subsubsection*{Bootstrapping reputation}\label{sec:bootstrapping-rep}

Since a permissionless colony's decision making procedure rests on reputation weighted voting, we are presented with a bootstrapping problem for new colonies. When a permissionless colony is new, no-one has yet completed any work in it and so nobody will have earned any reputation. Consequently, no objections can be raised and no disputes can be resolved as no-one is able to vote. Then, once the first task is successfully completed, that user has a dictatorship over decisions in the same domains or skills until another user earns similar types of reputation.

To prevent this, when a colony is created, the creator can choose addresses to have initial reputation assigned to them in the root domain to allow the colony to bootstrap itself. The reputation assigned to each user will be equal to the number of tokens received, i.e. if a member receives ten tokens, they also receive ten reputation in the root domain. Given that reputation decays over time, this initial bootstrapping will not have an impact on the long-term operation of the colony. This is the only time that reputation can be created without an associated expenditure being paid out. Users receiving reputation are presumably the colony founder and their colleagues, and this starting reputation should be seen as a representation of the existing trust which exists within the team.

We note that the same is not required when a new domain is created in a colony. We do not wish to allow the creation of new reputation here, as this would devalue reputation already earned elsewhere in the colony. This bootstrapping issue is resolved by instead using reputation within the parent domain, when a child domain contains less than 10\% of the reputation of its parent domain. A domain below this threshold cannot have domains created under it.

\subsubsection*{Reputation decay}

All reputation decays over time. Every \repdecayduration\ days, a user's reputation in every domain or skill decays by a factor of 2. This decay occurs every \miningcycleduration\ hours, rather than being a step change every \repdecayduration\ days to ensure there are minimal incentives to earn reputation at any particular time. This frequent, network-wide update is the primary reason for the existence of the reputation mining protocol, which allows this near-continuous decay to be calculated off-chain without gas limits, and then realised on-chain.

The decay serves multiple purposes. It ensures that reputation scores represent \emph{recent} contributions to a colony incentivising members to continually contribute to the colony. It further ensures that wild appreciations in token value (and the corresponding decrease in tokens paid per task) do not permanently distort the distribution of reputation but instead serves to smooth out the effects of such fluctuations over time. \\

One might wonder why we have chosen to \textit{decay} reputation, rather than pursue a strategy of reputation \textit{dilution} via inflation. In one sense, they are equivalent: decaying reputation that is earned at a constant rate is the same as earning reputation at increasingly inflated valuations. From an implementation perspective, however, reputation inflation has several flaws. First and most importantly, reputation can be decayed indefinitely, but only inflated up until the largest number the system can hold, at which point reputation will overflow. In Ethereum's case, it is a 256-bit integer, or roughly $10^{78}$ -- a stupendously large number. Were inflation to occur \textit{linearly} (`by fixed amounts') then the overflow would occur billions or more years in the future -- arguably a nonissue.

However, linear inflation is insufficient, as it would lead to a `relative slowing' of the inflation rate over time. Only \textit{exponential} (`by multiples') inflation allows us to combine reputation earned yesterday with reputation earned today, and to correctly treat them as one value moving forward, while maintaining a consistent rate of change. And with exponential inflation, the time to overflow approaches rapidly. Given the current reputation half-life of \repdecayduration\ days, equivalent inflation would overflow in less than 50 years.

One might argue that, were Colony to become wildly successful, several decades is ample time to develop a workaround for integer overflow. Even so, the main argument for reputation inflation is that it can be performed on-chain, and Colony reputation cannot be stored on-chain, for the reason that Colony reputation is not a single number, but many numbers. Inflation and decay aside, earning reputation entails looping over unbounded arrays (an entire domain hierarchy, for instance), and so is unsuitable for on-chain implementation. Given that reputation must be maintained off-chain, decay is the superior choice.

\subsubsection{On-chain representation of skills and domains}\label{subsec:on-chain-representation-of-skills}

In the context of reputation, domains and skills are the same, differing only in that domains are colony-specific categorisation and skills are universal categorisation. In this subsection, each instance of `skill' should be taken to mean `skill or domain'.

Each skill that reputation can be earned in is assigned a \ascode{skillId} that is unique across the whole network. When a skill is created, additional properties are recorded and initialised.

\begin{equation*}
  \ascode{skillId} \rightarrow
  \begin{cases}
    \ascode{nParents} &	\textnormal{total number of parent skills.}\\
    \ascode{nChildren} &	\textnormal{total number of child skills.}\\
    \ascode{parents}\left[\cdots\right] &	\parbox[t]{.6\linewidth}{\textnormal{array of \ascode{skillId}s of a \textit{logarithmic subset} of parent skills, where \ascode{parents[i]} gives the $2^i$-th parent.}}\\
    \ascode{children}\left[\cdots\right] &	\textnormal{array of \ascode{skillId}s of \textit{all} child skills.}\\
    \ascode{globalSkill} &	\textnormal{whether the skill is a skill or domain.}\\
    \ascode{deprecated} &	\textnormal{whether the skill has been deprecated.}
  \end{cases}
\end{equation*}

Upon creation, \ascode{nChildren} is 0 and \ascode{children[]} is empty. These two attributes in all parents are updated with the \ascode{skillId} of the new child skill on creation.\footnote{We acknowledge that this is fundamentally gas limited, but the only consequence of this will be the inability to create new skills once the maximum depth allowed by the block size is reached. Back-of-the-envelope calculations suggest this corresponds to a depth of around 80, which we don't believe our users will be limited by.}

Storing these pieces of data on-chain is required, as they are used by the reputation mining protocol (see Section \ref{sec:reputationmining}) and the procedures for escalating disputes (see Section \ref{sec:objections-and-disputes}). They are stored under the control of the \ascode{ColonyNetwork} contract.

\subsubsection{Reputation update log}\label{subsec:reputation-update-log}

Whenever an event that causes one or more users to have their reputation updated in a colony occurs, a corresponding entry is recorded in a log in the \code{ColonyNetwork} contract. Each entry in the log contains:

\begin{itemize}
\item The user experiencing the reputation loss or gain.
\item The amount of reputation to be lost or gained.
\item The \texttt{skillId} of the reputation to be lost or gained.
\item The colony the update has occurred in.
\item How many reputation entries will need to be updated (including parent, child and colony-wide total reputations). This is the motivation for storing \ascode{nParents} and \ascode{nChildren} for each skill and domain.
\item How many total updates to reputations have occurred before this one in this cycle, including decays and updates to parents and children.
\end{itemize}

If the reputation update is the result of a dispute being resolved (as outlined in Section \ref{sec:earning-rep-in-disputes}), then instead of these first three properties, there is a reference to the dispute-specific record of stakes in the relevant colony. For the structure of this log, and an explanation of the way that it allows individual updates to be extracted in constant gas, see Appendix \ref{appendix:rep-transfer}.

This log exists to define an ordering of all reputation updates in a reputation update cycle that is accessible on-chain. In the event of a dispute during the reputation mining protocol (described in Section \ref{sec:reputationmining}), the \ascode{ColonyNetwork} contract can use this record to establish whether an update has been included correctly.

\subsection{Managing stakes}\label{sec:stakes}

Staking is a key concept in permissionless systems, as a way to ensure that participants have `skin in the game' and can be incentivized towards good behavior. As Colony wishes to enable an ecosystem of extensions implementing various cryptoeconomic mechanisms (see Section \ref{sec:extensions}), a shared system for managing stakes improves usability and security by saving users from needing to send and retrieve tokens to and from many different contracts. \textbf{In colonies, all stakes are denominated in that colony's internal token.}

\subsubsection{Storing Tokens}

All stakes are stored in the network-wide \texttt{TokenLocking} contract. A singleton contract has the advantage that in scenarios where a user is a member of multiple colonies sharing the same internal token, a single deposit suffices for all colonies.

Any slashing of stakes occurs as a result of a function call coming from the \textit{colony} and is a result of colony-specific arbitration logic.

\subsubsection{Approvals and Obligations}

Stakes are managed via a sequence of \textit{approvals} and \textit{obligations}. Users \textit{approve} an address to then \textit{obligate} them up to the maximum amount of their approval. If an obligation is made in excess of the deposits held in the \texttt{TokenLocking} contract, the transaction will fail. Once an obligation is made, a user cannot withdraw tokens if the withdrawal would result in a balance less than their obligations. At any time, the approved extension can \textit{deobligate} the user, freeing the tokens for withdrawal (see Figure \ref{fig:stake-deobligate}). In practice, we expect that the same underlying deposit will be obligated and deobligated repeatedly without the user needing to move any additional tokens.

\begin{figure}[h]
    \centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    enlargelimits=0.2,
    legend style={at={(0.5,-0.15)},
      anchor=north,legend columns=-1},
    ylabel={Tokens},
    symbolic x coords={1. Approve,2. Obligate,3. Deobligate},
    xtick=data,
    ]
\addplot coordinates {(1. Approve,8) (2. Obligate,2) (3. Deobligate,2)};
\addplot coordinates {(1. Approve,0) (2. Obligate,6) (3. Deobligate,0)};
\addplot coordinates {(1. Approve,10) (2. Obligate,10) (3. Deobligate,10)};
\legend{Approval,Obligation,Deposit}
\end{axis}
\end{tikzpicture}
 \caption{Example stake lifecycle with deobligation}
 \label{fig:stake-deobligate}
\end{figure}

While an obligation is active, any \textbf{arbitration} role holder can \textit{slash} the stake up to the amount of the obligation (see Figure \ref{fig:stake-slash}).

\begin{figure}[h]
    \centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    enlargelimits=0.2,
    legend style={at={(0.5,-0.15)},
      anchor=north,legend columns=-1},
    ylabel={Tokens},
    symbolic x coords={1. Approve,2. Obligate,3. Slash},
    xtick=data,
    ]
\addplot coordinates {(1. Approve,8) (2. Obligate,2) (3. Slash,2)};
\addplot coordinates {(1. Approve,0) (2. Obligate,6) (3. Slash,0)};
\addplot coordinates {(1. Approve,10) (2. Obligate,10) (3. Slash,4)};
\legend{Approval,Obligation,Deposit}
\end{axis}
\end{tikzpicture}
 \caption{Example stake lifecycle with slashing}
 \label{fig:stake-slash}
\end{figure}

For reasons of security, approvals are keyed by \textit{domain}, as well as by address of approvee (i.e. \texttt{approve(approvee, domain, amount)}). This is because otherwise, a malicious actor could use \textit{any} arbitration role holder in the colony to slash a stake, rather than arbitration role holders in the intended domain inheritance path. However, because \texttt{TokenLocking} does not know about the domain structure of specific colonies, the obligations in \texttt{TokenLocking} are aggregates of all colony- and domain-specific obligations.

Overall, this design allows arbitration to be generalized and separated from the implementation of any particular extension: extensions obligate a stake (and define the period of obligation), while during that period separate arbitration processes can slash that stake.

\subsection{Upgradability and security}\label{subsec:upgradability}\label{sec:escape-hatches}

\subsubsection{Upgradability}

We foresee the Colony Network being continuously developed. Providing an upgrade path is important to allow people to use Colony without preventing themselves from using new features as they are added to the network.

We intend to allow colonies and tokens to be upgraded by using the pattern made available under the name EtherRouter \cite{EtherRouter}. This implementation uses two contracts in addition to the contract(s) providing the functionality implemented. The first additional contract is the \ascode{EtherRouter} contract, which passes on transactions --- via \ascode{delegatecall} --- to the contract that implements that function. The second additional contract is the \ascode{Resolver} contract, where the addresses of the contracts that implement the desired behaviour are defined. Whenever a transaction is received by the \ascode{EtherRouter} contract, it looks up the contract that implements that function (if any) in the \ascode{Resolver}, and then \ascode{delegatecall}s that contract.

In order to upgrade, new contracts are deployed with new functionality, and then contracts that the \ascode{Resolver} contract points to must be changed to point to these new contracts. In order to avoid a situation where the contract partially implements both old and new functionality,  a new instance of \ascode{Resolver} will be deployed for each upgrade, and then a single transaction can point \ascode{EtherRouter} at the new \ascode{Resolver}. From the perspective of the colony, an upgrade is then simply swapping out one address (the \ascode{Resolver}) for another.

The choice of upgrading the underlying Colony contract will always fall to the colony, and never the Colony Network. While the network is in control of what upgrades are available, they are not able to force any colony to upgrade the underlying contracts. The colony itself must decide that it wants to upgrade to a new version.

\subsubsection{Security}

While we aspire to bug-free contracts, bugs are inevitable, and so the adoption of a `defensive programming' mentality will limit the impact of any vulnerabilities that may be discovered in the deployed contracts.

The ultimate fallback is known as `recovery mode'. In this state, whitelisted addresses (those with the \textbf{recovery} role) are able to access special functions that allow the state of the contract to be directly edited --- in practise, this will correspond to access to the functions to allow setting of variables, as well as being able to upgrade the contract. With the agreement of multiple whitelisted addresses, the contract will then be able to be taken out of recovery mode once the contract has been returned to a safe state. Removal from recovery mode requires the approval of multiple whitelisted addresses. This ensures that a single whitelisted address cannot, in a single transaction, enter recovery mode, make a malicious edit, and then exit recovery mode before the other parties on the whitelist have had a chance to react.

It is conceivable that colonies will be able to deactivate the recovery mode feature in the future, once the network and contracts have matured sufficiently. \\

In general, the contract may enter recovery mode due to:

\begin{itemize}
 \item A transaction from a whitelisted address signalling that the contract should enter recovery mode.
 \item Something that should always be true of the colony not being true --- for example, after a task payout checking that the amount of funds promised to tasks and not yet paid out is still less than the balance of the colony. If not, then abort the transaction and put the contract into recovery mode.
 \item A qualitative trigger suggesting something may be amiss --- perhaps too many tokens have been paid out in a short amount of time.
\end{itemize}

Any approvals from whitelisted addresses to leave recovery mode must be reset whenever a variable is edited. A whitelisted address agreeing to leave recovery mode records the timestamp at which the agreement occurred, and any change of variables also update a timestamp indicating the last edit. When attempting to leave recovery mode, only agreements made after the last edit are counted towards meeting the threshold.

The first \textbf{recovery} role holder is set at colony creation and is the creator of the colony. Additional \textbf{recovery} role holders can be added by the \textbf{root} role.

\subsection{Arbitrary transactions}\label{sec:arbitrary-transaction}

Of course, it is possible that a colony will want to engage in some behaviour that we haven't foreseen, that could be implemented in a contract outside the control of the Colony Network. To that end, we wish to have a mechanism by which a colony can create an arbitrary transaction on the blockchain to interact with contracts and tokens without requiring the network to explicitly support them. As they are powerful, such transactions should be rare occurrences requiring \textbf{root} authorization.
