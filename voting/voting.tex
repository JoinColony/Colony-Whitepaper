\section{Voting}\label{sec:voting}
Voting is a necessity in the Colony Network. In a smoothly running colony, votes will not be needed, but once there is a disagreement, or there is the need to change something that will affect a large number of people, a poll will be needed to gauge the opinion of those in a domain or even whole colony.

\subsection{Reputation weighted voting}
Most votes in a colony will be due to disputes (see Section \ref{sec:disputes}). In these cases, the weights of the users' votes is proportional to the reputation that each user has in the domain and skill that the vote is taking place in. When such a vote starts, the current reputation state is stored alongside the vote. This allows the current reputation state to be `frozen' for the context of the vote, and prevents unwanted behaviours that might otherwise be encouraged (for example, delaying submission of a task until closer to voting so that the reputation earned has not decayed as much).

Voting takes place using a commit-and-reveal-scheme. To make a vote, the user submits a hash that is \ascode{keccak(secret, vote\_id)}, where \ascode{vote\_id} indicates the option that the user is voting for. Once voting has closed, the poll enters the reveal phase, where a user can submit \ascode{secret, vote\_id} and the contract calculates \ascode{keccak(secret, vote\_id)} to verify it is what they originally submitted.

As the secret is revealed it cannot be sensitive. It must also change with each vote so that observers cannot establish what people are voting for after they have revealed their first vote. We suggest a (hash) of the question the poll is asking signed with their private key. This is easily reproducible by a client at a later date with no local storage required.

When revealing their vote, the user also supplies a Merkle proof of their relevant reputation contained within the reputation state that was saved at the start of the vote. The total vote for the option they demonstrated they voted for is then incremented appropriately.

\subsection{Token weighted voting}
Unlike with reputation, we do not have the ability to `freeze' the token distribution when a vote starts. While this is effectively possible with something like the MiniMe token \cite{minime}, we envision token-weighted votes will still be regular enough within a Colony that we do not wish to burden users with the gas costs of deploying a new contract every time.

Instead, once a vote enters the reveal phase, any user who has voted on that vote will find themselves unable to see tokens sent to them, or be able to send tokens themselves --- their token balance has become locked. To unlock their token balance, they only have to reveal their vote. In this way, a user never finds themselves waiting for time to pass to unlock their tokens, as was the case with ``The DAO''. Instead, to unlock their tokens, they only have to reveal the vote they cast for any polls that have entered the reveal phase --- something they can do at any time. An implementation of this can be found on the Colony blog \cite{ColonyVoting}.

The primary use of a token weighted vote is related to the management of the colony tokens itself (Section \ref{sec:colony-token-management}); it seems reasonable that the decision and ability to create more tokens should lie with the colony token holders, rather than those with reputation who don't necessarily hold any tokens.

\subsection{Hybrid voting}
A hybrid vote would allow both reputation holders and token holders to vote on a decision. When such a vote takes place, the total reputation and the total token holdings each represent 50\% of the voting weight.